{"version":3,"sources":["webpack:///./src/audio.js","webpack:///./src/bigButton.js","webpack:///./src/clip.js","webpack:///./src/clipCommander.js","webpack:///./src/clipMaster.js","webpack:///./src/index.js","webpack:///./src/measuresAndRemainder.js","webpack:///./src/memory.js","webpack:///./src/sampleSource.js","webpack:///./src/sampleStream.js","webpack:///./src/wavMaker.js","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":[],"mappings":";;;;;;;AAAa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iC;;;;;;;AC1Ca;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB;AACjB,wBAAwB,mBAAO,CAAC,GAAiB;AACjD,qBAAqB,mBAAO,CAAC,GAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe,EAAE;AACtD;AACA;AACA,iBAAiB;AACjB,qC;;;;;;;AChEa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY;AACZ,+BAA+B,mBAAO,CAAC,GAAwB;AAC/D,mBAAmB,mBAAO,CAAC,GAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gC;;;;;;;AC1Fa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB;AACrB,eAAe,mBAAO,CAAC,GAAQ;AAC/B,+BAA+B,mBAAO,CAAC,GAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa,SAAS,0BAA0B;AACvE,oCAAoC;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,yC;;;;;;;ACjFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sC;;;;;;;AChFa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,GAAS;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC,iBAAiB,mBAAO,CAAC,GAAU;AACnC,uBAAuB,mBAAO,CAAC,GAAgB;AAC/C,uBAAuB,mBAAO,CAAC,GAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iC;;;;;;;AC3Ba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,gD;;;;;;;ACda;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;;AClBa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,yBAAyB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB,wC;;;;;;;AC9Fa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa,YAAY,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,wC;;;;;;;ACrFa;AACb;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oC;;;;;;UCjDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;UCrBA;UACA;UACA;UACA","file":"main.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Audio = void 0;\nclass Audio {\n    constructor(context) {\n        this.audioCtx = context;\n    }\n    static make() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ctx = yield Audio.getAudioContext();\n            return new Promise((resolve, reject) => {\n                resolve(new Audio(ctx));\n            });\n        });\n    }\n    static getAudioContext() {\n        return new Promise((resolve, reject) => {\n            const context = new window.AudioContext();\n            if (context.state === 'running') {\n                resolve(context);\n            }\n            else {\n                setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    resolve(yield Audio.getAudioContext());\n                }), 500);\n            }\n        });\n    }\n    static HzFromNote(note) {\n        return 440 * Math.pow(2, (note - 69) / 12);\n    }\n}\nexports.Audio = Audio;\n//# sourceMappingURL=audio.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BigButton = void 0;\nconst clipCommander_1 = require(\"./clipCommander\");\nconst clipMaster_1 = require(\"./clipMaster\");\nclass BigButton {\n    constructor(audioContext, sampleStream) {\n        this.mode = 'stopped';\n        this.canvas = null;\n        this.loopStartS = null;\n        this.loopLengthS = null;\n        this.kPaddingS = 1.0;\n        this.clipMaster = new clipMaster_1.ClipMaster(audioContext);\n        this.audioCtx = audioContext;\n        this.sampleStream = sampleStream;\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = 400;\n        this.canvas.height = 400;\n        this.canvas.classList.add('bigButton');\n        this.canvas.addEventListener('pointerdown', (ev) => {\n            this.press();\n        });\n        const body = document.getElementsByTagName('body')[0];\n        body.appendChild(this.canvas);\n        this.render();\n    }\n    press() {\n        const pressTime = this.audioCtx.currentTime;\n        if (this.mode === 'recording') {\n            this.loopLengthS = pressTime - this.loopStartS;\n            const buffer = this.sampleStream.createAudioBuffer(this.loopStartS - this.kPaddingS, pressTime + this.kPaddingS);\n            const clipCommander = new clipCommander_1.ClipCommander(this.audioCtx, buffer, this.kPaddingS, this.loopLengthS, this.clipMaster);\n        }\n        switch (this.mode) {\n            case 'stopped':\n                this.mode = 'recording';\n                break;\n            case 'recording':\n                this.mode = 'stopped';\n                break;\n        }\n        if (this.mode === 'recording') {\n            this.loopStartS = pressTime;\n        }\n    }\n    render() {\n        const ctx = this.canvas.getContext('2d');\n        ctx.strokeStyle = 'black';\n        switch (this.mode) {\n            case 'stopped':\n                ctx.strokeStyle = '#000';\n                break;\n            case 'recording':\n                ctx.strokeStyle = '#f00';\n                break;\n        }\n        ctx.lineWidth = 40;\n        ctx.lineCap = 'round';\n        ctx.arc(200, 200, 150, -Math.PI, Math.PI);\n        ctx.stroke();\n        requestAnimationFrame(() => { this.render(); });\n    }\n}\nexports.BigButton = BigButton;\n//# sourceMappingURL=bigButton.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Clip = void 0;\nconst measuresAndRemainder_1 = require(\"./measuresAndRemainder\");\nconst wavMaker_1 = require(\"./wavMaker\");\nclass Clip {\n    constructor(audioContext, buffer, startOffsetS, durationS) {\n        this.audioNode = null;\n        this.audioCtx = audioContext;\n        this.startOffsetS = startOffsetS;\n        this.naturalDurationS = durationS;\n        this.loopDurationS = durationS;\n        this.buffer = buffer;\n        this.armed = false;\n    }\n    isArmed() {\n        return this.armed;\n    }\n    setArmed(armed) {\n        this.armed = armed;\n    }\n    DataURLFromUint8(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Use a FileReader to generate a base64 data URI\n            const base64url = yield new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result.toString());\n                reader.readAsDataURL(new Blob([data]));\n            });\n            return base64url;\n        });\n    }\n    stop(stopTimeS) {\n        if (this.audioNode) {\n            this.audioNode.stop(stopTimeS);\n            this.audioNode = null;\n        }\n    }\n    start(startTimeS) {\n        // Start cannot be called twice on an AudioBufferSourceNode\n        // we must stop the old one and create a new one to restart the sound.\n        if (this.audioNode) {\n            this.audioNode.stop();\n        }\n        this.audioNode = this.audioCtx.createBufferSource();\n        this.audioNode.buffer = this.buffer;\n        this.audioNode.loop = true;\n        this.audioNode.loopStart = this.startOffsetS;\n        this.audioNode.loopEnd = this.startOffsetS + this.loopDurationS;\n        this.audioNode.connect(this.audioCtx.destination);\n        this.audioNode.start(startTimeS, this.startOffsetS);\n    }\n    changeStart(deltaS) {\n        this.startOffsetS += deltaS;\n    }\n    changeDuration(deltaS) {\n        this.naturalDurationS += deltaS;\n        if (this.naturalDurationS < 0.1) {\n            this.naturalDurationS = 0.1;\n        }\n    }\n    toDataUri() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = wavMaker_1.WavMaker.makeWav(this.audioCtx, this.buffer, this.startOffsetS, this.loopDurationS);\n            // const f = new File([data.buffer], \"clip.wav\");\n            // ev.dataTransfer.files = [f];\n            const stringData = yield this.DataURLFromUint8(new Uint8Array(data.buffer));\n            return new Promise((resolve, reject) => {\n                resolve(stringData);\n            });\n        });\n    }\n    getDuration() {\n        return this.naturalDurationS;\n    }\n    setBpm(bpm) {\n        const mar = new measuresAndRemainder_1.MeasuresAndRemainder(this.naturalDurationS, bpm);\n        this.loopDurationS = mar.quantizedS;\n    }\n}\nexports.Clip = Clip;\n//# sourceMappingURL=clip.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClipCommander = void 0;\nconst clip_1 = require(\"./clip\");\nconst measuresAndRemainder_1 = require(\"./measuresAndRemainder\");\nclass ClipCommander {\n    constructor(audioContext, buffer, startOffsetS, durationS, clipMaster) {\n        this.audioCtx = audioContext;\n        this.clipMaster = clipMaster;\n        this.clip = new clip_1.Clip(audioContext, buffer, startOffsetS, durationS);\n        this.div = document.createElement('span');\n        this.div.innerText = 'clip';\n        this.div.classList.add('clip');\n        this.div.tabIndex = 1;\n        this.div.draggable = true;\n        const body = document.getElementsByTagName('body')[0];\n        body.appendChild(this.div);\n        this.div.addEventListener('keydown', (ev) => {\n            let actionTaken = true;\n            switch (ev.code) {\n                case 'ArrowRight':\n                    this.clip.changeStart(0.01);\n                    break;\n                case 'ArrowLeft':\n                    this.clip.changeStart(-0.01);\n                    break;\n                case 'ArrowDown':\n                    this.clip.changeDuration(-0.1);\n                    break;\n                case 'ArrowUp':\n                    this.clip.changeDuration(0.1);\n                    break;\n                default: actionTaken = false;\n            }\n            if (actionTaken) {\n                const mar = new measuresAndRemainder_1.MeasuresAndRemainder(this.clip.getDuration(), this.clipMaster.getBpm());\n                this.div.innerText =\n                    `${mar.measures} bars (${mar.remainderS.toFixed(3)})`;\n                this.makeDownload(); // TODO: debounce?\n                this.clipMaster.start(audioContext.currentTime);\n            }\n        });\n        this.div.addEventListener('dragstart', (ev) => __awaiter(this, void 0, void 0, function* () {\n            ev.dataTransfer.setData(\"audio/x-wav\", yield this.clip.toDataUri());\n            ev.dataTransfer.effectAllowed = \"copy\";\n        }));\n        this.div.addEventListener('pointerdown', (ev) => {\n            this.div.classList.toggle('armed');\n            this.clip.setArmed(this.div.classList.contains('armed'));\n            this.clipMaster.start(this.audioCtx.currentTime);\n        });\n        this.clipMaster.addClip(this.clip);\n        this.makeDownload();\n    }\n    makeDownload() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let a = null;\n            for (const elt of this.div.getElementsByTagName('a')) {\n                a = elt;\n                break;\n            }\n            if (a === null) {\n                a = document.createElement('a');\n                a.download = 'clip.wav';\n                a.innerText = 'download';\n                this.div.appendChild(a);\n            }\n            a.href = yield this.clip.toDataUri();\n        });\n    }\n}\nexports.ClipCommander = ClipCommander;\n//# sourceMappingURL=clipCommander.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClipMaster = void 0;\nclass ClipMaster {\n    constructor(audioContext) {\n        this.clips = [];\n        this.bpm = null;\n        const body = document.getElementsByTagName('body')[0];\n        const bpmContainer = document.createElement('div');\n        this.bpmDiv = document.createElement('span');\n        this.bpmDiv.innerText = 'NA';\n        this.bpmDiv.tabIndex = 1;\n        bpmContainer.appendChild(this.bpmDiv);\n        const bpmText = document.createElement('span');\n        bpmText.innerText = 'BPM';\n        bpmText.classList.add('bpmText');\n        bpmContainer.appendChild(bpmText);\n        body.appendChild(bpmContainer);\n        this.bpmDiv.addEventListener('keydown', (ev) => {\n            if (!this.bpm) {\n                return;\n            }\n            let actionTaken = true;\n            switch (ev.code) {\n                case 'Equal':\n                case 'ArrowRight':\n                case 'ArrowUp':\n                    this.bpm += 0.1;\n                    break;\n                case 'Minus':\n                case 'ArrowLeft':\n                case 'ArrowDown':\n                    this.bpm -= 0.1;\n                    break;\n                default:\n                    actionTaken = false;\n                    break;\n            }\n            if (actionTaken) {\n                for (const c of this.clips) {\n                    c.setBpm(this.bpm);\n                }\n                this.bpmDiv.innerText = this.bpm.toFixed(1);\n                this.start(audioContext.currentTime);\n            }\n        });\n    }\n    start(startTimeS) {\n        for (const clip of this.clips) {\n            if (clip.isArmed()) {\n                clip.start(startTimeS);\n            }\n            else {\n                clip.stop(startTimeS);\n            }\n        }\n    }\n    durationToBeats(durationS) {\n        let bpm = 60.0 / durationS;\n        let beats = 1;\n        while (bpm < 84) {\n            bpm *= 2;\n            beats *= 2;\n        }\n        bpm = Math.round(bpm * 10) / 10;\n        this.bpm = bpm;\n        this.bpmDiv.innerText = bpm.toFixed(1);\n    }\n    addClip(clip) {\n        this.clips.push(clip);\n        if (!this.bpm) {\n            this.durationToBeats(clip.getDuration());\n        }\n        clip.setBpm(this.bpm);\n    }\n    getBpm() {\n        return this.bpm;\n    }\n}\nexports.ClipMaster = ClipMaster;\n//# sourceMappingURL=clipMaster.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst audio_1 = require(\"./audio\");\nconst bigButton_1 = require(\"./bigButton\");\nconst memory_1 = require(\"./memory\");\nconst sampleSource_1 = require(\"./sampleSource\");\nconst sampleStream_1 = require(\"./sampleStream\");\nconsole.log(\"Breathe.\");\nfunction go() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const m = new memory_1.Memory();\n        const audio = yield audio_1.Audio.make();\n        const ss = yield sampleSource_1.SampleSource.make(audio);\n        const stream = new sampleStream_1.SampleStream(ss, audio.audioCtx);\n        const bb = new bigButton_1.BigButton(audio.audioCtx, stream);\n    });\n}\ngo();\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MeasuresAndRemainder = void 0;\nclass MeasuresAndRemainder {\n    constructor(durationS, bpm) {\n        let secondsPerMeasure = 4 * 60 / bpm;\n        let measureCount = Math.round(durationS / secondsPerMeasure);\n        measureCount = Math.max(1, measureCount);\n        this.quantizedS = measureCount * secondsPerMeasure;\n        this.measures = measureCount;\n        this.remainderS = durationS - this.quantizedS;\n    }\n}\nexports.MeasuresAndRemainder = MeasuresAndRemainder;\n//# sourceMappingURL=measuresAndRemainder.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Memory = void 0;\nclass Memory {\n    constructor() {\n        const div = document.createElement('div');\n        const body = document.getElementsByTagName('body')[0];\n        body.appendChild(div);\n        const f = function () {\n            div.innerText = (window.performance\n                .memory.usedJSHeapSize / 1000000).toFixed(3)\n                + \"MB\";\n            setTimeout(f, 100);\n        };\n        f();\n    }\n}\nexports.Memory = Memory;\n//# sourceMappingURL=memory.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SampleSource = void 0;\nclass SampleSource {\n    constructor(audio) {\n        this.previousMax = 0.0;\n        this.audio = audio;\n        this.audioCtx = audio.audioCtx;\n    }\n    static make(audio) {\n        const self = new SampleSource(audio);\n        console.log(\"Attempting to initialize.\");\n        console.assert(!!navigator.mediaDevices.getUserMedia);\n        var constraints = {\n            audio: true,\n            video: false,\n            echoCancellation: false,\n            noiseSuppersion: false,\n        };\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            self.handleStream(stream, resolve);\n        }));\n    }\n    setListener(callback) {\n        this.listener = callback;\n    }\n    setUpAnalyser(mediaSource) {\n        const body = document.getElementsByTagName('body')[0];\n        const div = document.createElement('div');\n        div.classList.add('vu');\n        body.appendChild(div);\n        const analyser = this.audioCtx.createAnalyser();\n        analyser.fftSize = 2048;\n        this.mediaSource.connect(analyser);\n        const dataArray = new Float32Array(analyser.frequencyBinCount);\n        const render = () => {\n            analyser.getFloatTimeDomainData(dataArray);\n            let m = this.previousMax * 0.95;\n            for (let i = 0; i < dataArray.length; ++i) {\n                m = Math.max(m, Math.abs(dataArray[i]));\n            }\n            this.previousMax = m;\n            div.innerText = m.toFixed(2);\n            if (m >= 0.9) {\n                div.classList.remove('low');\n                div.classList.remove('mid');\n                div.classList.add('hig');\n            }\n            else if (m >= 0.5) {\n                div.classList.remove('low');\n                div.classList.add('mid');\n                div.classList.remove('hig');\n            }\n            else {\n                div.classList.add('low');\n                div.classList.remove('mid');\n                div.classList.remove('hig');\n            }\n            requestAnimationFrame(render);\n        };\n        requestAnimationFrame(render);\n    }\n    handleStream(stream, resolve) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.mediaSource = this.audioCtx.createMediaStreamSource(stream);\n            this.setUpAnalyser(this.mediaSource);\n            yield this.audioCtx.audioWorklet.addModule(`sampleSourceWorker.js?buster=${Math.random().toFixed(6)}`);\n            const worklet = new AudioWorkletNode(this.audioCtx, 'sample-source');\n            let workerStartTime = this.audioCtx.currentTime;\n            let workerElapsedFrames = 0;\n            worklet.port.onmessage = (event) => {\n                setTimeout(() => {\n                    workerElapsedFrames += event.data.newSamples.length;\n                    const chunkEndTime = workerStartTime +\n                        workerElapsedFrames / this.audioCtx.sampleRate;\n                    this.listener(event.data.newSamples, chunkEndTime);\n                }, 0);\n            };\n            this.mediaSource.connect(worklet);\n            resolve(this);\n        });\n    }\n}\nexports.SampleSource = SampleSource;\n//# sourceMappingURL=sampleSource.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SampleStream = void 0;\nclass PendingWork {\n    constructor(buffer, startOffset) {\n        this.buffer = buffer;\n        this.startOffset = startOffset;\n    }\n}\nclass SampleStream {\n    constructor(sampleSource, audioContext) {\n        this.chunks = [];\n        this.pending = [];\n        this.audioCtx = audioContext;\n        sampleSource.setListener((samples, endTimeS) => {\n            this.handleSamples(samples, endTimeS);\n        });\n    }\n    createAudioBuffer(startS, endS) {\n        console.log(`Chunks: ${this.chunks.length}`);\n        const frameCount = (endS - startS) * this.audioCtx.sampleRate;\n        const buffer = this.audioCtx.createBuffer(1, frameCount, this.audioCtx.sampleRate);\n        const data = buffer.getChannelData(0);\n        let framesToSkip = this.audioCtx.sampleRate * (startS - this.startTimeS);\n        let framesRemaining = frameCount;\n        let chunkIndex = 0;\n        let targetOffset = 0;\n        while (framesRemaining > 0 && chunkIndex < this.chunks.length) {\n            const currentChunkSize = this.chunks[chunkIndex].length;\n            if (framesToSkip < currentChunkSize) {\n                const frameStart = framesToSkip;\n                const frameEnd = Math.min(currentChunkSize, framesToSkip + framesRemaining);\n                for (let i = frameStart; i < frameEnd; ++i) {\n                    data[targetOffset++] = this.chunks[chunkIndex][i];\n                }\n                framesRemaining -= (frameEnd - frameStart);\n            }\n            framesToSkip = Math.max(0, framesToSkip - currentChunkSize);\n            ++chunkIndex;\n        }\n        console.log(`Using ${targetOffset} frames.  ${framesRemaining} blank.`);\n        if (framesRemaining > 0) {\n            this.pending.push(new PendingWork(data, data.length - framesRemaining));\n        }\n        while (framesRemaining > 0) {\n            data[targetOffset++] = 0;\n            --framesRemaining;\n        }\n        return buffer;\n    }\n    fillWork(pending, source) {\n        const buffer = pending.buffer;\n        let targetOffset = pending.startOffset;\n        let sourceOffset = 0;\n        while (targetOffset < buffer.length && sourceOffset < source.length) {\n            buffer[targetOffset++] = source[sourceOffset++];\n        }\n        pending.startOffset = targetOffset;\n    }\n    handleSamples(samples, endTimeS) {\n        const durationS = samples.length / this.audioCtx.sampleRate;\n        if (this.chunks.length === 0) {\n            this.startTimeS = endTimeS - durationS;\n            this.endTimeS = this.startTimeS;\n        }\n        for (const pendingItem of this.pending) {\n            this.fillWork(pendingItem, samples);\n        }\n        while (this.pending.length > 0 &&\n            this.pending[0].startOffset >= this.pending[0].buffer.length) {\n            this.pending.shift();\n        }\n        this.chunks.push(samples);\n        let recordedDurationS = this.endTimeS - this.startTimeS;\n        // Maximum 15 minutes of recording time.  Rather excessive.\n        while (recordedDurationS > 60 * 15) {\n            const chunkDuration = this.chunks[0].length / this.audioCtx.sampleRate;\n            this.startTimeS += chunkDuration;\n            recordedDurationS -= chunkDuration;\n            this.chunks.shift();\n        }\n        this.endTimeS += durationS;\n    }\n}\nexports.SampleStream = SampleStream;\n//# sourceMappingURL=sampleStream.js.map","\"use strict\";\n// Cribbed from https://github.com/awslabs/aws-lex-browser-audio-capture/blob/master/lib/worker.js\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WavMaker = void 0;\n// Better ??? https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API\n// Not sure how to use an offline audio context or otherwise create an offline stream...\nclass WavMaker {\n    static makeWav(audioContext, buffer, startOffsetS, durationS) {\n        const samples = new Float32Array(audioContext.sampleRate * durationS);\n        let sampleIndex = 0;\n        let sourceIndex = Math.trunc(startOffsetS * audioContext.sampleRate);\n        const sourceData = buffer.getChannelData(0);\n        while (sampleIndex < samples.length) {\n            samples[sampleIndex++] = sourceData[sourceIndex++];\n        }\n        return WavMaker.makeWavFromFloat32(audioContext.sampleRate, samples);\n    }\n    static floatTo16BitPCM(output, offset, input) {\n        for (var i = 0; i < input.length; i++, offset += 2) {\n            var s = Math.max(-1, Math.min(1, input[i]));\n            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        }\n    }\n    static writeString(view, offset, s) {\n        for (var i = 0; i < s.length; i++) {\n            view.setUint8(offset + i, s.charCodeAt(i));\n        }\n    }\n    static makeWavFromFloat32(sampleRate, samples) {\n        var buffer = new ArrayBuffer(44 + samples.length * 2);\n        var view = new DataView(buffer);\n        WavMaker.writeString(view, 0, 'RIFF');\n        view.setUint32(4, 32 + samples.length * 2, true);\n        WavMaker.writeString(view, 8, 'WAVE');\n        WavMaker.writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        view.setUint16(22, 1, true);\n        view.setUint32(24, sampleRate, true);\n        view.setUint32(28, sampleRate * 2, true);\n        view.setUint16(32, 2, true);\n        view.setUint16(34, 16, true);\n        WavMaker.writeString(view, 36, 'data');\n        view.setUint32(40, samples.length * 2, true);\n        WavMaker.floatTo16BitPCM(view, 44, samples);\n        return view;\n    }\n}\nexports.WavMaker = WavMaker;\n//# sourceMappingURL=wavMaker.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(138);\n"],"sourceRoot":""}